const clone = require('clone');
const config = require('./config');

let db = {};

// Rework shape so that:
  // - categories have retrievable id at the top level allowing for selection by categories[id]
  // - categories have full object that also includes id
  // - category object marks whether or not deleted
  // - categories shape and attribs cohere with shape and attribs of posts and comments
  //    1) category attrib in posts points to category.id, not category.name
  //    2) OR category name is unique and therefore taken to be its id (then add a displayName/title for 'Udacity Network')
  //    - option #1 as more 
// Develop in parallel to spot any frontend errors generated by changes
const defaultData = {
  categories: [
      {
        name: 'react',
        path: 'react'
      },
      {
        name: 'redux',
        path: 'redux'
      },
      {
        name: 'udacity',
        path: 'udacity'
      }
  ]
};

// proposed shape of Categories
const testCategoryShape = {
  categories: {
    'uuid_123abc': {
      id: 'uuid_123abc',
      name: 'react',
      path: 'react',
      deleted: false
    },
    'uuid_890xyz': {
      id: 'uuid_890xyz',
      name: 'redux',
      path: 'redux',
      deleted: false
    },
    'uuid_567lmn': {
      id: 'uuid_567lmn',
      name: 'udacity',
      path: 'udacity',
      deleted: false
    }
  }
};

// rework so that only non-deleted categories are returned
function getData (token) {
  //Each token has it's own copy of the DB. The token in this case is like an app id.
  let data = db[token];
  //This populates the default user data if there isn't any in the db.
  if (data == null) {
    data = db[token] = clone(defaultData);
  }
  return data;
}

function getAll (token) {
  return new Promise((res) => {
    res(getData(token));
  });
}

// TODO update after commend shape is updated to reflect new category shape
function add (token, category) {
  return new Promise((res) => {
    let categories = getData(token);
    categories.push({
      name: category.name,
      path: category.path
    });
    res(categories.filter(categoryObj => categoryObj.name === category.name)[0]);
  });
}

// TODO make sure comment shape is updated, then edit returned categories through id
function edit (token, id, category) {
  return new Promise((res) => {
    let categories = getData(token);
    // this reassigns local var but does give the desired result
    categories = [...categories.filter(categoryObj => categoryObj.name !== category.name), category];
    // TODO redo categories simply to use id
    for (prop in category) {
      categories[id][prop] = category[prop];
    }
    res(comments[id]);
  });
}

// TODO make sure comment shape is updated before testing
function disable (token, id) {
  return new Promise(res => {
    let categories = getData(token);
    categories[id].deleted = true;
    res(categories[id]);
  });
}

module.exports = {
  getAll
};
