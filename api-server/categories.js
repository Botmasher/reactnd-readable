const clone = require('clone');
const config = require('./config');

let db = {};

// new shape of Categories overwriting previous: [{name, path}, ... ]
const defaultData = {
  'react': {
    name: 'react',
    path: 'react',
    displayName: 'React',
    timestamp: Date.now(),
    deleted: false
  },
  'redux': {
    name: 'redux',
    path: 'redux',
    displayName: 'Redux',
    timestamp: Date.now(),
    deleted: false
  },
  'udacity': {
    name: 'udacity',
    path: 'udacity',
    displayName: 'Udacity',
    timestamp: Date.now(),
    deleted: false
  }
};

// Work through frontend errors generated by changes
  // - categories keys are retrievable unique name at the top level: categories[name]
  // - category values are full object that also includes unique name: categories[name] returns {name, path, ...}
  // - category object marks whether or not deleted: {name, path, ..., deleted: false}
  // - categories shape and attribs cohere with shape and attribs of posts and comments
  //    - category name is unique and therefore taken to be its id (then add a displayName/title for 'Udacity Network')


function getData (token) {
  //Each token has it's own copy of the DB. The token in this case is like an app id.
  let data = db[token];
  //This populates the default user data if there isn't any in the db.
  if (data == null) {
    data = db[token] = clone(defaultData);
  }
  return data;
}

function getAll (token) {
  return new Promise((res) => {
    const data = getData(token);
     // return all categories not flagged as deleted
    const categories = Object.keys(data).reduce((filteredCategories, categoryName) => {
      return data[categoryName].deleted
        ? filteredCategories
        : {
            ...filteredCategories,
            [categoryName]: data[categoryName]
          }
      ;
    }, {});
    res({ categories });
  });
}

function add (token, category) {
  return new Promise((res) => {
    let categories = getData(token);
    categories[category.name] = {
      name: category.name,
      path: category.path,
      timestamp: Date.now(),
      deleted: false
    };
    res(categories[category.name]);
  });
}

function edit (token, name, category) {
  return new Promise((res) => {
    let categories = getData(token);

    for (prop in category) {
      categories[name][prop] = category[prop];
    }
    res(categories[name]);
  });
}

function disable (token, name) {
  return new Promise(res => {
    let categories = getData(token);
    categories[name].deleted = true;
    res(categories[name]);
  });
}

module.exports = {
  getAll
};
