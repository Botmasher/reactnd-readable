const clone = require('clone');
const config = require('./config');

let db = {};

// Rework shape so that:
  // - categories have retrievable id at the top level allowing for selection by categories[id]
  // - categories have full object that also includes id (unique name)
  // - category object marks whether or not deleted
  // - categories shape and attribs cohere with shape and attribs of posts and comments
  //    1) category attrib in posts points to category.id, not category.name
  //    2) OR category name is unique and therefore taken to be its id (then add a displayName/title for 'Udacity Network')
  //    - option #1 as more 
// Develop in parallel to spot any frontend errors generated by changes
const defaultData = {
  categories: [
      {
        name: 'react',
        path: 'react'
      },
      {
        name: 'redux',
        path: 'redux'
      },
      {
        name: 'udacity',
        path: 'udacity'
      }
  ]
};

// proposed shape of Categories
const testCategoryShape = {
  categories: {
    'react': {
      name: 'react',
      path: 'react',
      timestamp: Date.now(),
      deleted: false
    },
    'redux': {
      name: 'redux',
      path: 'redux',
      timestamp: Date.now(),
      deleted: false
    },
    'udacity': {
      name: 'udacity',
      path: 'udacity',
      timestamp: Date.now(),
      deleted: false
    }
  }
};

// rework so that only non-deleted categories are returned
function getData (token) {
  //Each token has it's own copy of the DB. The token in this case is like an app id.
  let data = db[token];
  //This populates the default user data if there isn't any in the db.
  if (data == null) {
    data = db[token] = clone(defaultData);
  }
  return data;
}

function getAll (token) {
  return new Promise((res) => {
    const data = getData(token);
    res(Object.keys(data).reduce((filteredCategories, categoryName) => {
      return data[categoryName].deleted
        ? filteredCategories
        : {
            ...filteredCategories,
            [categoryName]: data[categoryName]
          }
      ;
    }, {}));
  });
}

function add (token, category) {
  return new Promise((res) => {
    let categories = getData(token);
    categories[category.name] = {
      name: category.name,
      path: category.path,
      timestamp: Date.now(),
      deleted: false
    };
    res(categories[category.name]);
  }
}

function edit (token, name, category) {
  return new Promise((res) => {
    let categories = getData(token);

    for (prop in category) {
      categories[name][prop] = category[prop];
    }
    res(categories[name]);
  });
}

function disable (token, name) {
  return new Promise(res => {
    let categories = getData(token);
    categories[name].deleted = true;
    res(categories[name]);
  });
}

module.exports = {
  getAll
};
